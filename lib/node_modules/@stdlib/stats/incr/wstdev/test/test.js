/**
* @license Apache-2.0
*
* Copyright (c) 2018 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require('tape');
var isnan = require('@stdlib/math/base/assert/is-nan');
var incrwstdev = require('./../lib'); // Replace with actual path


// TESTS //

tape('main export is a function', function test(t) {
    t.ok(true, __filename);
    t.strictEqual(typeof incrwstdev, 'function', 'main export is a function');
    t.end();
});

tape('the function returns an accumulator function', function test(t) {
    t.equal(typeof incrwstdev(), 'function', 'returns a function');
    t.end();
});

tape('the accumulator function computes an incremental weighted standard deviation', function test(t) {
    var data = [2.0, 3.0, 2.0, 4.0, 3.0, 4.0];
    var weights = [1.0, 0.5, 1.5, 1.0, 0.75, 1.25];
    var expected = [
        0.0,
        0.5,
        0.7071067811865476,
        1.0,
        0.7745966692414834,
        0.9128709291752769
    ];

    var acc = incrwstdev();
    var actual = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
        actual[i] = acc(data[i], weights[i]);
    }
    t.deepEqual(actual, expected, 'returns expected incremental results');
    t.end();
});

tape('if no inputs are provided, the result is `null`', function test(t) {
    var acc = incrwstdev();
    t.equal(acc(), null, 'returns null without inputs');
    t.end();
});

tape('returns `null` if all weights are zero', function test(t) {
    var data = [1.0, 2.0, 3.0];
    var weights = [0, 0, 0];
    var acc = incrwstdev();

    for (var i = 0; i < data.length; i++) {
        acc(data[i], weights[i]);
    }
    t.equal(acc(), null, 'returns null when all weights are zero');
    t.end();
});

tape('returns 0 when all data points are identical with non-zero weights', function test(t) {
    var data = [3.0, 3.0, 3.0];
    var weights = [1.0, 0.5, 1.5];
    var acc = incrwstdev();

    for (var i = 0; i < data.length; i++) {
        t.equal(acc(data[i], weights[i]), 0.0, 'returns 0 for identical data points');
    }
    t.equal(acc(), 0.0, 'final accumulated value is 0');
    t.end();
});

tape('NaN propagation: if any data or weight is NaN, all future results are NaN', function test(t) {
    var data = [2.0, NaN, 3.0];
    var weights = [1.0, 1.0, 0.5];
    var acc = incrwstdev();

    for (var i = 0; i < data.length; i++) {
        t.equal(isnan(acc(data[i], weights[i])), true, 'returns NaN if any input is NaN');
    }
    t.equal(isnan(acc()), true, 'final accumulated value is NaN');
    t.end();
});

tape('zero or negative weights return null and do not affect the result', function test(t) {
    var data = [2.0, 3.0, 4.0];
    var weights = [1.0, 0.0, -1.0];
    var acc = incrwstdev();

    for (var i = 0; i < data.length; i++) {
        acc(data[i], weights[i]);
    }
    t.equal(acc(), null, 'returns null if all weights are zero or negative');
    t.end();
});

tape('handles very small weights without underflow', function test(t) {
    var data = [2.0, 3.0, 2.0];
    var weights = [1e-10, 2e-10, 1e-10];
    var acc = incrwstdev();

    for (var i = 0; i < data.length; i++) {
        acc(data[i], weights[i]);
    }
    t.ok(acc() >= 0, 'returns a non-negative standard deviation with very small weights');
    t.end();
});

tape('handles large weights without overflow', function test(t) {
    var data = [2.0, 3.0, 4.0];
    var weights = [1e10, 1e10, 1e10];
    var acc = incrwstdev();

    for (var i = 0; i < data.length; i++) {
        acc(data[i], weights[i]);
    }
    t.ok(acc() >= 0, 'returns a non-negative standard deviation with very large weights');
    t.end();
});

tape('non-numeric inputs for data or weights throw errors', function test(t) {
    var acc = incrwstdev();
    var badData = [true, 'text', [], {}, null, undefined];
    var weight = 1.0;

    badData.forEach(function(badValue) {
        t.throws(function() {
            acc(badValue, weight);
        }, TypeError, 'throws error for non-numeric data: ' + badValue);
    });

    var data = 2.0;
    var badWeights = [true, 'text', [], {}, null, undefined];

    badWeights.forEach(function(badValue) {
        t.throws(function() {
            acc(data, badValue);
        }, TypeError, 'throws error for non-numeric weight: ' + badValue);
    });

    t.end();
});

tape('when no value is provided, the function returns the current weighted standard deviation', function test(t) {
    var data = [2.0, 4.0, 6.0];
    var weights = [1.0, 2.0, 3.0];
    var acc = incrwstdev();

    data.forEach(function(value, i) {
        acc(value, weights[i]);
    });
    t.equal(acc(), 1.632993161855452, 'returns the correct current weighted standard deviation');
    t.end();
});

tape('returns null when only one valid data-weight pair has been provided', function test(t) {
    var acc = incrwstdev();
    acc(3.0, 1.0);
    t.equal(acc(), null, 'returns null when only one pair is provided');
    t.end();
});

tape('handles large variance in data points', function test(t) {
    var data = [1e-10, 1e10];
    var weights = [1.0, 1.0];
    var acc = incrwstdev();

    for (var i = 0; i < data.length; i++) {
        acc(data[i], weights[i]);
    }
    t.ok(acc() > 0, 'handles high variance without underflow or overflow');
    t.end();
});

tape('handles large datasets and remains performant', function test(t) {
    var acc = incrwstdev();
    var data = [];
    var weights = [];
    var n = 100000;

    for (var i = 0; i < n; i++) {
        data.push(Math.random() * 100);
        weights.push(Math.random());
        acc(data[i], weights[i]);
    }

    t.ok(!isnan(acc()), 'returns a valid standard deviation for large dataset');
    t.end();
});

