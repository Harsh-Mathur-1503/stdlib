/**
* @license Apache-2.0
*
* Copyright (c) 2024 The Stdlib Authors.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

'use strict';

// MODULES //

var tape = require( 'tape' );
var isnan = require( '@stdlib/math/base/assert/is-nan' );
var PINF = require( '@stdlib/constants/float64/pinf' );
var NINF = require( '@stdlib/constants/float64/ninf' );
var lcmf = require( './../lib' );

// TESTS //

tape( 'main export is a function', function test( t ) {
	t.ok( true, __filename );
	t.strictEqual( typeof lcmf, 'function', 'main export is a function' );
	t.end();
});

tape( 'the function returns `NaN` if input is `NaN`', function test( t ) {
	var v;

	v = lcmf( NaN );
	t.strictEqual( isnan( v ), true, 'returns NaN' );

	t.end();
});

tape( 'the function returns `NaN` if input is `+infinity`', function test( t ) {
	var v;

	v = lcmf( PINF );
	t.strictEqual( isnan( v ), true, 'returns NaN' );

	t.end();
});

tape( 'the function returns `NaN` if input is `-infinity`', function test( t ) {
	var v;

	v = lcmf( NINF );
	t.strictEqual( isnan( v ), true, 'returns NaN' );

	t.end();
});

tape( 'the function returns `NaN` if input is not an integer value', function test( t ) {
	var v;

	v = lcmf( 3.14 );
	t.strictEqual( isnan( v ), true, 'returns NaN' );

	v = lcmf( 6.18 );
	t.strictEqual( isnan( v ), true, 'returns NaN' );

	t.end();
});

tape( 'the function returns `0` if input is `0`', function test( t ) {
	var v;

	v = lcmf( 0 );
	t.strictEqual( v, 0, 'returns 0' );

	t.end();
});

tape( 'the function computes the least common multiple of a number with 1 (LCM(a, 1) = a)', function test( t ) {
	var v;

	v = lcmf( 6 );
	t.strictEqual( v, 6, 'returns 6' );

	v = lcmf( 10 );
	t.strictEqual( v, 10, 'returns 10' );

	v = lcmf( -7 );
	t.strictEqual( v, 7, 'returns 7' );

	v = lcmf( 21 );
	t.strictEqual( v, 21, 'returns 21' );

	v = lcmf( 0 );
	t.strictEqual( v, 0, 'returns 0' );

	v = lcmf( 1 );
	t.strictEqual( v, 1, 'returns 1' );

	t.end();
});


tape( 'the function returns `NaN` if input is a non-integer floating point number', function test( t ) {
	var v;

	v = lcmf( 3.14159 );
	t.strictEqual( isnan( v ), true, 'returns NaN for float' );

	v = lcmf( 6.28 );
	t.strictEqual( isnan( v ), true, 'returns NaN for float' );

	v = lcmf( -1.1 );
	t.strictEqual( isnan( v ), true, 'returns NaN for negative float' );

	t.end();
});

tape( 'the function handles negative numbers correctly (LCM of negative numbers)', function test( t ) {
	var v;

	v = lcmf( -6 );
	t.strictEqual( v, 6, 'returns 6 for negative input' );

	v = lcmf( -10 );
	t.strictEqual( v, 10, 'returns 10 for negative input' );

	v = lcmf( -25 );
	t.strictEqual( v, 25, 'returns 25 for negative input' );

	v = lcmf( -21 );
	t.strictEqual( v, 21, 'returns 21 for negative input' );

	v = lcmf( -100 );
	t.strictEqual( v, 100, 'returns 100 for negative input' );

	t.end();
});

tape( 'the function computes the least common multiple of two integers', function test( t ) {
	var v;

	v = lcmf( 12 ); // LCM(12, 1)
	t.strictEqual( v, 12, 'returns 12' );

	v = lcmf( 15 ); // LCM(15, 1)
	t.strictEqual( v, 15, 'returns 15' );

	v = lcmf( 24 ); // LCM(24, 1)
	t.strictEqual( v, 24, 'returns 24' );

	v = lcmf( 35 ); // LCM(35, 1)
	t.strictEqual( v, 35, 'returns 35' );

	v = lcmf( 45 ); // LCM(45, 1)
	t.strictEqual( v, 45, 'returns 45' );

	t.end();
});

tape( 'the function computes LCM for large inputs', function test( t ) {
	var v;

	v = lcmf( 1000 );
	t.strictEqual( v, 1000, 'returns 1000 for large number' );

	v = lcmf( 10000 );
	t.strictEqual( v, 10000, 'returns 10000 for large number' );

	v = lcmf( 50000 );
	t.strictEqual( v, 50000, 'returns 50000 for large number' );

	v = lcmf( 100000 );
	t.strictEqual( v, 100000, 'returns 100000 for large number' );

	t.end();
});

tape( 'the function handles the special case of LCM with zero (LCM(0, a) = 0)', function test( t ) {
	var v;

	v = lcmf( 0 );
	t.strictEqual( v, 0, 'returns 0 when input is 0' );

	t.end();
});

tape( 'the function computes LCM for numbers with common factors', function test( t ) {
	var v;

	v = lcmf( 18 ); // LCM(18, 1)
	t.strictEqual( v, 18, 'returns 18' );

	v = lcmf( 28 ); // LCM(28, 1)
	t.strictEqual( v, 28, 'returns 28' );

	v = lcmf( 36 ); // LCM(36, 1)
	t.strictEqual( v, 36, 'returns 36' );

	v = lcmf( 48 ); // LCM(48, 1)
	t.strictEqual( v, 48, 'returns 48' );

	t.end();
});

